<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1D Flow Model Visualization</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: white;
        }
        /* Modified for canvas overlay */
        #visualization-container {
            position: relative;
            width: 100%;
            height: 350px;
        }
        #plot-container {
            width: 100%;
            height: 100%;
            background-color: white;
            border-radius: 10px;
            box-shadow: none;
        }
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 10px;
            cursor: grab;
        }
        #particle-canvas.dragging {
            cursor: grabbing;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        button {
            margin: 0 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .animation-button {
            background-color: #2196F3;
        }
        .animation-button:hover {
            background-color: #0b7dda;
        }
        /* Rounded corners for the heatmap */
        .heatmap-wrapper {
            width: 100%;
            height: 350px;
            overflow: hidden;
            border-radius: 20px;
            position: relative;
            background-color: white;
            box-shadow: none;
        }
        #plot-container {
            border-radius: 0;
            box-shadow: none;
        }
        .slider-container {
            margin: 20px auto;
            width: 300px;
            text-align: center;
        }
        
        /* New CSS for side-by-side sliders */
        .sliders-wrapper {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px auto;
            flex-wrap: wrap;
        }
        
        .slider-container.side-by-side {
            margin: 0;
            width: 280px;
            text-align: center;
        }
        
        .slider-container label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
        }
        .slider {
            width: 100%;
            height: 5px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #18327E;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #18327E;
            cursor: pointer;
            border: none;
        }
        .slider-value {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #18327E;
        }
        .info-text {
            text-align: center;
            margin-top: 10px;
            color: #666;
            font-size: 14px;
        }
        
        /* New CSS for the three buttons */
        .top-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .top-buttons button {
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 14px;
            font-weight: bold;
            background-color: #18327E;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            opacity: 1.0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .top-buttons button:hover:not(:disabled) {
            opacity: 0.8;
            transform: translateY(-2px);
        }
        
        .top-buttons button.active {
            opacity: 1;
            background-color: #C8372C;
        }
        
        .top-buttons button:disabled {
            cursor: not-allowed;
            opacity: 1.0;
        }
        
        /* Reset button styling */
        .reset-button {
            width: 36px !important;
            height: 36px !important;
            border-radius: 8px !important;
            padding: 0 !important;
            background-color: #F1A948 !important;
            opacity: 1.0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            margin-left: 20px !important;
        }
        
        .reset-button:hover {
            background-color: #555 !important;
            opacity: 1.0 !important;
            transform: translateY(-2px) !important;
        }
        
        .reset-button.active {
            background-color: #666 !important;
        }
        
        /* Mobile-specific CSS */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            #visualization-container {
                height: 250px; /* Optimized mobile height */
            }
            
            .heatmap-wrapper {
                height: 250px; /* Match container height */
                margin-bottom: 15px; /* Reduce spacing */
            }
            
            .top-buttons {
                gap: 8px;
                margin-bottom: 8px;
            }
            
            .top-buttons button {
                width: 42px; /* Slightly larger for touch */
                height: 42px;
                font-size: 16px;
            }
            
            /* Adjust arrow positioning for mobile */
            .top-buttons button:nth-child(1)::after,
            .top-buttons button:nth-child(2)::after {
                right: -12px;
                border-left-width: 5px;
                border-top-width: 3px;
                border-bottom-width: 3px;
            }
            
            .reset-button {
                width: 42px !important;
                height: 42px !important;
                margin-left: 10px !important;
            }
            
            .sliders-wrapper {
                flex-direction: column;
                align-items: center;
                gap: 15px; /* Tighter spacing */
                margin: 15px auto; /* Less margin */
            }
            
            .slider-container.side-by-side {
                width: 280px; /* Smaller width */
            }
            
            .info-text {
                font-size: 12px;
                padding: 0 5px;
                margin-top: 8px; /* Less margin */
            }
            
            /* Touch-friendly sliders */
            .slider {
                height: 8px;
            }
            
            .slider::-webkit-slider-thumb {
                width: 25px;
                height: 25px;
            }
            
            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
            }
        }
        
        /* Desktop optimization */
        @media (min-width: 769px) {
            #visualization-container {
                height: 380px; /* Taller on desktop to fill space */
            }
            
            .heatmap-wrapper {
                height: 380px;
            }
        }

        .reset-icon {
            width: 20px;
            height: 20px;
            color: white;
            transition: transform 0.2s ease;
        }
        
        .reset-button:hover .reset-icon {
            transform: rotate(-15deg);
        }
        
        .reset-button:active .reset-icon {
            transform: rotate(-30deg);
        }
        
        /* Arrow between buttons 1 and 2 */
        .top-buttons button:nth-child(1)::after {
            content: '';
            position: absolute;
            right: -14px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid #18327E;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Arrow between buttons 2 and 3 */
        .top-buttons button:nth-child(2)::after {
            content: '';
            position: absolute;
            right: -14px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid #18327E;
            border-top: 4px solid transparent;
            border-bottom: 4px solid transparent;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Update arrow colors when button is active */
        .top-buttons button.active:nth-child(1)::after,
        .top-buttons button.active:nth-child(2)::after {
            border-left-color: #C8372C;
        }
    </style>
</head>
<body>
    <div class="top-buttons">
        <button id="sampleBtn" onclick="handleStageButton(0)">1</button>
        <button id="advantageBtn" onclick="handleStageButton(1)" disabled>2</button>
        <button id="redirectBtn" onclick="handleStageButton(2)" disabled>3</button>
        <button id="resetBtn" class="reset-button" onclick="resetVisualization()" title="Reset visualization">
            <svg class="reset-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 12C4 7.58172 7.58172 4 12 4C14.5264 4 16.7792 5.17107 18.2454 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                <path d="M20 12C20 16.4183 16.4183 20 12 20C9.47363 20 7.22075 18.8289 5.75463 17" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                <path d="M15 7L18.5 7L18.5 3.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M9 17L5.5 17L5.5 20.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </button>
    </div>
    <div class="heatmap-wrapper">
        <div id="visualization-container">
            <div id="plot-container"></div>
            <canvas id="particle-canvas"></canvas>
        </div>
    </div>
    <div class="info-text" id="infoText">
        Flow Policy Optimization
    </div>

    <script>
        // Mobile detection
        const isMobile = window.innerWidth <= 768;
        
        // Parameters
        const xMin = -1.7;
        const xMax = 1.7;
        const nPoints = 300;
        const nTimeSteps = 200;
        
        // Current data distribution type
        let currentDataType = 'bimodal';
        
        // Stochasticity scale factor
        let stochasticityScale = 0.2;
        
        // Particle addition rate (0 = no particles, 1 = particles every frame)
        let particleRate = 0.2;
        
        // Animation speed multiplier - configurable in code only
        const animationSpeed = 0.2; // Change this value to adjust animation speed (0.5-5.0 recommended)
        
        // Show particle traces - set to false for better performance with many particles
        const showParticleTraces = true; // Set to false to disable trajectory lines
        
        // Canvas setup
        let canvas = null;
        let ctx = null;
        let canvasWidth = 0;
        let canvasHeight = 0;
        
        // Coordinate mapping cache
        let coordinateMapping = null;
        let dataDistCoordinateMapping = null; // Separate mapping for data distribution plot
        let advantageCoordinateMapping = null; // For advantage plot (rightmost trace)
        
        // Customizable data modes - these will be modified by dragging
        let customDataModes = {
            bimodal: [
                {mean: -0.7, std: 0.3, weight: 0.6},
                {mean: 0.7, std: 0.3, weight: 0.4}
            ],
            trimodal: [
                {mean: -1, std: 0.3, weight: 0.33},
                {mean: 0, std: 0.3, weight: 0.34},
                {mean: 1, std: 0.3, weight: 0.33}
            ]
        };
        
        // Customizable advantage modes - now only 2 modes
        let advantageModes = [
            {mean: -0.5, std: 0.4, weight: 0.45},
            {mean: 0.6, std: 0.3, weight: 0.55}
        ];
        
        // Number of centroids for k-means clustering
        const numCentroids = 3;
        
        // Stage management
        let currentStage = -1; // -1: initial, 0: sample, 1: advantage, 2: redirect
        let stageData = {
            particleEndPositions: [],
            centroids: [],
            scaledCentroids: [],
            targetModes: null,
            transitionProgress: 0,
            samplingActive: false
        };
        
        // Dragging state
        let isDragging = false;
        let draggedModeIndex = -1;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartWeight = 0;
        let dragStartMean = 0;
        
        // Control point rendering parameters
        const controlPointRadius = isMobile ? 12 : 8; // Larger on mobile for touch
        const controlPointHoverRadius = isMobile ? 16 : 10;
        let hoveredModeIndex = -1;
        
        // Particle system
        class Particle {
            constructor() {
                this.x = sampleStandardNormal() * 0.6;
                // Clamp x to min and max
                this.x = Math.max(xMin + 0.1, Math.min(xMax - 0.1, this.x));
                this.t = 0;
                this.trajectory = showParticleTraces ? [{t: 0, x: this.x}] : [];
                const colorPairs = [
                    ['#C3D898', '#F45B69'],
                    ['#F5B0CB', '#791E94'],
                    ['#FCFAFA', '#f7c814'],
                    ['#FCFAFA', '#a5f0ea'],
                ]
                const colorPair = colorPairs[Math.floor(Math.random() * colorPairs.length)];
                this.color = colorPair[0];
                this.radiusColor = colorPair[1];
                this.id = Math.random();
                this.fading = false;
                this.opacity = 1.0;
                this.fadeDuration = 0.5; // Time in seconds to fade out
                this.hasReachedEnd = false;
                this.isAccumulated = false; // New flag for accumulated particles
            }
            
            update(dt, dataType) {
                // Handle accumulated particles (never fade)
                if (this.isAccumulated) {
                    return true; // Keep particle alive forever
                }
                
                if (this.fading) {
                    // Particle is fading out
                    this.opacity -= dt / this.fadeDuration;
                    return this.opacity > 0; // Remove when fully faded
                }
                
                if (this.t >= 1) {
                    // Particle reached end
                    if (!this.hasReachedEnd) {
                        this.hasReachedEnd = true;
                        // Record end position for stage 1
                        if (currentStage === 0) {
                            stageData.particleEndPositions.push(this.x);
                            this.isAccumulated = true; // Mark as accumulated
                        }
                    }
                    
                    // In stage 0, keep particle visible at end
                    if (currentStage === 0) {
                        return true;
                    }
                    
                    // Otherwise start fading
                    this.fading = true;
                    this.opacity = 1.0;
                    return true; // Keep particle for fading
                }
                
                const actualDt = Math.min(dt, 1 - this.t);
                const {drift, diffusion} = computeFlowVelocity(this.x, this.t, dataType, actualDt);
                
                const noise = sampleStandardNormal();
                this.x += drift * actualDt + diffusion * noise;
                this.t += actualDt;
                
                // Only store trajectory points if traces are enabled and at intervals to reduce memory
                if (showParticleTraces && 
                    (this.trajectory.length === 0 || 
                     this.t - this.trajectory[this.trajectory.length - 1].t > 0.02)) {
                    this.trajectory.push({t: this.t, x: this.x});
                }
                
                return true; // Keep particle alive
            }
            
            // Helper method to get color with current opacity
            getColorWithOpacity() {
                // Extract HSL values from the color string
                const hslMatch = this.color.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
                if (hslMatch) {
                    const [, h, s, l] = hslMatch;
                    return `hsla(${h}, ${s}%, ${l}%, ${Math.max(0, this.opacity)})`;
                }
                // Fallback if color format is different
                return this.color;
            }
        }
        
        let particles = [];
        let animationId = null;
        let lastTimestamp = null;
        
        // Create x grid
        const xGrid = [];
        for (let i = 0; i < nPoints; i++) {
            xGrid.push(xMin + (xMax - xMin) * i / (nPoints - 1));
        }
        
        // Create extended x grid for side traces (to avoid clipping)
        const xMinExtended = -1.7;
        const xMaxExtended = 1.7;
        const nPointsExtended = 500;
        const xGridExtended = [];
        for (let i = 0; i < nPointsExtended; i++) {
            xGridExtended.push(xMinExtended + (xMaxExtended - xMinExtended) * i / (nPointsExtended - 1));
        }
        
        // Create time grid
        const tGrid = [];
        for (let i = 0; i < nTimeSteps; i++) {
            tGrid.push(i / (nTimeSteps - 1));
        }
        
        // Gaussian PDF
        function gaussianPDF(x, mean, std) {
            const variance = std * std;
            return Math.exp(-0.5 * Math.pow((x - mean), 2) / variance) / Math.sqrt(2 * Math.PI * variance);
        }
        
        // Sample from standard normal distribution
        function sampleStandardNormal() {
            const u1 = Math.random();
            const u2 = Math.random();
            return Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
        }
        
        // Prior distribution (standard Gaussian)
        function priorPDF(x) {
            return gaussianPDF(x, 0, 0.6);
        }
        
        // Advantage function - now uses customizable advantage modes
        function advantageFunction(x) {
            let pdf = 0;
            for (let mode of advantageModes) {
                pdf += mode.weight * gaussianPDF(x, mode.mean, mode.std);
            }
            return pdf;
        }
        
        // Get modes (peaks) of the data distribution
        function getDataModes(type) {
            return customDataModes[type];
        }
        
        // Data distribution (mixture of Gaussians) - now uses customizable modes
        function dataPDF(x, type) {
            const modes = getDataModes(type);
            let pdf = 0;
            for (let mode of modes) {
                pdf += mode.weight * gaussianPDF(x, mode.mean, mode.std);
            }
            return pdf;
        }
        
        // Compute the marginal distribution at time t for flow matching
        function flowPDF(x, t, type) {
            const modes = getDataModes(type);
            const priorStd = 0.6;
            
            // At time t, x_t = t*x_1 + (1-t)*x_0
            // where x_0 ~ N(0, σ_prior²) and x_1 ~ mixture of Gaussians
            
            // The marginal distribution is a mixture of Gaussians where each component
            // has mean t*μ_i and variance t²*σ_i² + (1-t)²*σ_prior²
            
            let pdf = 0;
            for (let mode of modes) {
                const meanAtT = t * mode.mean;
                const varAtT = t * t * mode.std * mode.std + (1 - t) * (1 - t) * priorStd * priorStd;
                const stdAtT = Math.sqrt(Math.max(0.01, varAtT)); // Prevent very small std
                
                const modeContribution = mode.weight * gaussianPDF(x, meanAtT, stdAtT);
                if (isFinite(modeContribution)) {
                    pdf += modeContribution;
                }
            }
            
            // Cap the maximum PDF value to prevent extreme values
            return Math.min(pdf, 50); // Reasonable upper limit for PDF values
        }
        
        // Compute posterior probabilities and means for each Gaussian component given x_t
        function computePosteriorWeights(x, t, type) {
            if (t <= 0) return {weights: [], posteriorMeans: [], modes: []};
            if (t >= 0.999) return {weights: [], posteriorMeans: [], modes: []}; // Avoid numerical issues
            
            const modes = getDataModes(type);
            const priorMean = 0;
            const priorStd = 0.6;
            
            // For flow matching, we have x_t = t*x_1 + (1-t)*x_0
            // where x_0 ~ prior distribution, x_1 ~ data distribution
            // Given x_t, we compute the posterior for x_1 from each mode
            
            const weights = [];
            const posteriorMeans = [];
            let totalWeight = 0;
            
            // Noise variance from the prior at time t
            const noiseVar = (1 - t) * (1 - t) * priorStd * priorStd;
            
            // Compute posterior for each mode
            for (let mode of modes) {
                // Prior: x_1 ~ N(μ_i, σ_i²)
                // Observation model: x_t = t*x_1 + noise, where noise ~ N(0, noiseVar)
                // This gives us x_t | x_1 ~ N(t*x_1, noiseVar)
                
                // Using Bayes rule for Gaussians:
                // Posterior precision: 1/σ_post² = 1/σ_i² + t²/noiseVar
                const priorVar = mode.std * mode.std;
                const posteriorPrecision = 1/priorVar + (t * t)/noiseVar;
                const posteriorVar = 1/posteriorPrecision;
                
                // Posterior mean: μ_post = σ_post² * (μ_i/σ_i² + t*x_t/noiseVar)
                const posteriorMean = posteriorVar * (mode.mean/priorVar + (t * x)/noiseVar);
                
                // The marginal likelihood P(x_t | mode i) is the normalizer from Bayes rule
                // x_t | mode i ~ N(t*μ_i, t²*σ_i² + noiseVar)
                const marginalMean = t * mode.mean;
                const marginalVar = t * t * priorVar + noiseVar;
                const marginalStd = Math.sqrt(marginalVar);
                
                const likelihood = mode.weight * gaussianPDF(x, marginalMean, marginalStd);
                
                weights.push(likelihood);
                posteriorMeans.push(posteriorMean);
                totalWeight += likelihood;
            }
            
            // Normalize weights
            if (totalWeight > 0) {
                for (let i = 0; i < weights.length; i++) {
                    weights[i] /= totalWeight;
                }
            }
            
            return {weights: weights, posteriorMeans: posteriorMeans, modes: modes};
        }
        
        // Compute the flow velocity analytically using proper flow matching formula
        function computeFlowVelocity(x, t, type, dt) {
            if (t <= 0) return {drift: 0, diffusion: 0};
            if (t >= 0.999) return {drift: 0, diffusion: 0}; // Avoid numerical issues near t=1
            
            // Get posterior weights and means for each mode
            const {weights, posteriorMeans, modes} = computePosteriorWeights(x, t, type);
            
            // Compute weighted posterior mean E[x_1 | x_t = x]
            let posteriorMean = 0;
            for (let i = 0; i < modes.length; i++) {
                posteriorMean += weights[i] * posteriorMeans[i];
            }
            
            // The velocity field for flow matching is:
            // v(x,t) = (posteriorMean - x) / (1 - t)
            // This moves particles from prior (t=0) to data (t=1)
            const drift = (posteriorMean - x) / (1 - t);
            
            // Diffusion coefficient - decreases with time
            // At t=0: maximum diffusion for exploration
            // At t=1: zero diffusion for convergence to target
            // The sqrt(dt) factor is for the Euler-Maruyama discretization
            const diffusionCoef = 0.5 * stochasticityScale * Math.sqrt(2 * (1 - t) * dt);
            
            return {drift: drift, diffusion: diffusionCoef};
        }
        
        // K-means clustering implementation
        function kMeansClustering(positions, k) {
            if (positions.length === 0) return [];
            
            // Initialize centroids randomly from data points
            let centroids = [];
            const shuffled = [...positions].sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(k, positions.length); i++) {
                centroids.push({
                    mean: shuffled[i],
                    points: [],
                    count: 0
                });
            }
            
            // K-means iterations
            const maxIterations = 50;
            for (let iter = 0; iter < maxIterations; iter++) {
                // Clear assignments
                centroids.forEach(c => {
                    c.points = [];
                    c.count = 0;
                });
                
                // Assign points to nearest centroid
                positions.forEach(pos => {
                    let minDist = Infinity;
                    let nearestCentroid = 0;
                    
                    for (let i = 0; i < centroids.length; i++) {
                        const dist = Math.abs(pos - centroids[i].mean);
                        if (dist < minDist) {
                            minDist = dist;
                            nearestCentroid = i;
                        }
                    }
                    
                    centroids[nearestCentroid].points.push(pos);
                    centroids[nearestCentroid].count++;
                });
                
                // Update centroid positions
                let converged = true;
                centroids.forEach(centroid => {
                    if (centroid.count > 0) {
                        const newMean = centroid.points.reduce((sum, p) => sum + p, 0) / centroid.count;
                        if (Math.abs(newMean - centroid.mean) > 0.001) {
                            converged = false;
                        }
                        centroid.mean = newMean;
                    }
                });
                
                if (converged) break;
            }
            
            // Calculate statistics for each centroid
            return centroids.filter(c => c.count > 0).map(centroid => {
                // Calculate standard deviation
                const variance = centroid.points.reduce((sum, p) => 
                    sum + Math.pow(p - centroid.mean, 2), 0) / centroid.count;
                const std = Math.max(0.15, Math.sqrt(variance)); // Increased minimum std from 0.15
                
                return {
                    mean: centroid.mean,
                    std: std,
                    count: centroid.count,
                    weight: centroid.count // Will be normalized later
                };
            });
        }
        
        // Apply advantage scaling to centroids
        function applyAdvantageScaling(centroids) {
            // First normalize centroid weights
            const totalCount = centroids.reduce((sum, c) => sum + c.count, 0);
            centroids.forEach(c => {
                c.weight = c.count / totalCount;
            });
            
            // Then scale by advantage
            return centroids.map(centroid => {
                const advantage = advantageFunction(centroid.mean);
                return {
                    ...centroid,
                    advantage: advantage,
                    scaledWeight: centroid.weight * advantage
                };
            });
        }
        
        // Normalize advantage-scaled centroids
        function normalizeAdvantageCentroids(centroids) {
            const totalWeight = centroids.reduce((sum, c) => sum + c.scaledWeight, 0);
            if (totalWeight > 0) {
                return centroids.map(centroid => ({
                    mean: centroid.mean,
                    std: centroid.std,
                    weight: centroid.scaledWeight / totalWeight,
                    advantage: centroid.advantage,
                    count: centroid.count
                }));
            }
            return centroids;
        }
        
        // Match old modes to new modes by proximity to minimize crossing
        function matchModesByProximity(oldModes, newModes) {
            if (oldModes.length === 0 || newModes.length === 0) {
                return { oldToNew: [], newToOld: [] };
            }
            
            // For each old mode, find the closest new mode
            const oldToNew = new Array(oldModes.length).fill(-1);
            const newToOld = new Array(newModes.length).fill(-1);
            const used = new Array(newModes.length).fill(false);
            
            // Sort old modes by their mean for stable matching
            const sortedOldIndices = oldModes.map((_, i) => i).sort((a, b) => oldModes[a].mean - oldModes[b].mean);
            
            // Match each old mode to the closest available new mode
            for (let oldIdx of sortedOldIndices) {
                let bestNewIdx = -1;
                let bestDistance = Infinity;
                
                for (let newIdx = 0; newIdx < newModes.length; newIdx++) {
                    if (used[newIdx]) continue;
                    
                    const distance = Math.abs(oldModes[oldIdx].mean - newModes[newIdx].mean);
                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestNewIdx = newIdx;
                    }
                }
                
                if (bestNewIdx !== -1) {
                    oldToNew[oldIdx] = bestNewIdx;
                    newToOld[bestNewIdx] = oldIdx;
                    used[bestNewIdx] = true;
                }
            }
            
            return { oldToNew, newToOld };
        }
        
        // Animation state tracking to prevent getting stuck
        let animationState = {
            transitionStartTime: null,
            maxTransitionDuration: 15000, // 15 seconds max
            lastProgressCheck: null,
            stuckCheckInterval: null
        };
        
        // Animate transition between distributions
        function animateDistributionTransition() {
            if (currentStage !== 2 || !stageData.targetModes) return;
            
            // Initialize timing on first call
            if (!animationState.transitionStartTime) {
                animationState.transitionStartTime = Date.now();
                animationState.lastProgressCheck = stageData.transitionProgress;
                
                // Set up stuck detection
                startStuckDetection();
            }
            
            const transitionSpeed = 0.08; // Increased from 0.02 to 0.08 for faster animation
            stageData.transitionProgress += transitionSpeed;
            
            // Force completion if taking too long
            const elapsed = Date.now() - animationState.transitionStartTime;
            if (elapsed > animationState.maxTransitionDuration) {
                console.warn('Transition taking too long, forcing completion');
                stageData.transitionProgress = 1;
            }
            
            if (stageData.transitionProgress >= 1) {
                // Transition complete
                completeTransition();
                return;
            }
            
            // Get the original modes at the start of transition
            if (!stageData.originalModes) {
                stageData.originalModes = [...getDataModes(currentDataType)];
            }
            
            const oldModes = stageData.originalModes;
            const newModes = stageData.targetModes;
            const t = stageData.transitionProgress;
            
            // Match modes by proximity to avoid crossing
            const { oldToNew, newToOld } = matchModesByProximity(oldModes, newModes);
            
            const interpolatedModes = [];
            
            // Handle matched pairs
            for (let oldIdx = 0; oldIdx < oldModes.length; oldIdx++) {
                const newIdx = oldToNew[oldIdx];
                if (newIdx !== -1) {
                    // Interpolate between matched modes
                    const interpolatedStd = oldModes[oldIdx].std * (1 - t) + newModes[newIdx].std * t;
                    interpolatedModes.push({
                        mean: oldModes[oldIdx].mean * (1 - t) + newModes[newIdx].mean * t,
                        std: Math.max(0.1, interpolatedStd), // Prevent std from becoming too small
                        weight: oldModes[oldIdx].weight * (1 - t) + newModes[newIdx].weight * t
                    });
                } else {
                    // Old mode fading out (no match found)
                    interpolatedModes.push({
                        ...oldModes[oldIdx],
                        std: Math.max(0.1, oldModes[oldIdx].std), // Ensure minimum std
                        weight: oldModes[oldIdx].weight * (1 - t)
                    });
                }
            }
            
            // Handle unmatched new modes (fading in)
            for (let newIdx = 0; newIdx < newModes.length; newIdx++) {
                if (newToOld[newIdx] === -1) {
                    // New mode fading in
                    interpolatedModes.push({
                        ...newModes[newIdx],
                        std: Math.max(0.1, newModes[newIdx].std), // Ensure minimum std
                        weight: newModes[newIdx].weight * t
                    });
                }
            }
            
            // Normalize weights
            const totalWeight = interpolatedModes.reduce((sum, mode) => sum + mode.weight, 0);
            if (totalWeight > 0) {
                interpolatedModes.forEach(mode => mode.weight /= totalWeight);
            }
            
            // Filter out modes with very small weights and validate std values
            const filteredModes = interpolatedModes.filter(mode => {
                return mode.weight > 0.001 && mode.std > 0.05 && isFinite(mode.mean) && isFinite(mode.std);
            });
            
            // Fallback: if no valid modes remain, use a safe default
            if (filteredModes.length === 0) {
                console.warn('No valid modes after filtering, using fallback');
                filteredModes.push({
                    mean: 0,
                    std: 0.3,
                    weight: 1.0
                });
            }
            
            customDataModes[currentDataType] = filteredModes;
            plotFlow();
            
            // Continue animation
            requestAnimationFrame(animateDistributionTransition);
        }
        
        // Complete the transition and restart cycle
        function completeTransition() {
            stageData.transitionProgress = 1;
            customDataModes[currentDataType] = [...stageData.targetModes];
            plotFlow();
            
            // Clean up animation state
            resetAnimationState();
            
            // Auto-restart the cycle after a brief pause (using tracked timeout)
            setTrackedTimeout(() => {
                if (currentStage !== 2) return; // Check if stage changed
                updateInfoText("Transition complete! Restarting cycle...");
                setTrackedTimeout(() => {
                    if (currentStage === 2) {
                        startStage0(); // Auto-restart the cycle
                    }
                }, 3000);
            }, 1000);
        }
        
        // Reset animation state tracking
        function resetAnimationState() {
            animationState.transitionStartTime = null;
            animationState.lastProgressCheck = null;
            
            if (animationState.stuckCheckInterval) {
                clearInterval(animationState.stuckCheckInterval);
                animationState.stuckCheckInterval = null;
            }
        }
        
        // Start detection for stuck animations
        function startStuckDetection() {
            // Clear any existing interval
            if (animationState.stuckCheckInterval) {
                clearInterval(animationState.stuckCheckInterval);
            }
            
            // Check every 2 seconds if animation is making progress
            animationState.stuckCheckInterval = setInterval(() => {
                if (currentStage === 2) {
                    const currentProgress = stageData.transitionProgress;
                    const timeSinceStart = Date.now() - animationState.transitionStartTime;
                    
                    // If no progress for 5 seconds OR total time exceeds limit, force completion
                    if (currentProgress === animationState.lastProgressCheck && timeSinceStart > 5000) {
                        console.warn('Animation appears stuck, forcing completion');
                        completeTransition();
                    } else if (timeSinceStart > animationState.maxTransitionDuration) {
                        console.warn('Animation timeout, forcing completion');
                        completeTransition();
                    } else {
                        animationState.lastProgressCheck = currentProgress;
                    }
                } else {
                    // Not in stage 2 anymore, clean up
                    resetAnimationState();
                }
            }, 2000);
        }
        
        // Handle window focus/blur to recover from stuck animations
        function handleWindowFocus() {
            // If we're stuck in stage 2 when regaining focus, check if we need to force completion
            if (currentStage === 2 && stageData.transitionProgress > 0) {
                const timeSinceStart = animationState.transitionStartTime ? 
                    Date.now() - animationState.transitionStartTime : 0;
                
                // If it's been too long, force completion
                if (timeSinceStart > animationState.maxTransitionDuration) {
                    console.warn('Recovered from stuck animation on window focus');
                    completeTransition();
                } else {
                    // Restart the animation
                    requestAnimationFrame(animateDistributionTransition);
                }
            }
        }
        
        // Handle stage button clicks
        function handleStageButton(stage) {
            if (stage === currentStage) return; // Already in this stage
            
            switch(stage) {
                case 0: // Sample Actions
                    startStage0();
                    break;
                case 1: // Scale by Advantage
                    if (currentStage === 0) {
                        startStage1();
                    }
                    break;
                case 2: // Redirect the Flow
                    if (currentStage === 1) {
                        startStage2();
                    }
                    break;
            }
        }
        
        // Start Stage 0: Sample Actions
        function startStage0() {
            currentStage = 0;
            updateButtonStates();
            
            // Reset stage data
            stageData = {
                particleEndPositions: [],
                centroids: [],
                scaledCentroids: [],
                targetModes: null,
                transitionProgress: 0,
                samplingActive: true
            };
            
            // Clear all particles and start fresh
            particles = [];
            
            // Temporarily increase particle rate for sampling
            const oldParticleRate = particleRate;
            particleRate = 0.8; // High rate for sampling phase
            
            // Start animation if not running
            if (!animationId) {
                startAnimation();
            }
            
            updateInfoText("Sampling actions...");
            
            // After a longer duration, stop adding new particles (using tracked timeout)
            setTrackedTimeout(() => {
                if (currentStage !== 0) return; // Check if stage changed
                particleRate = 0; // Stop adding particles
                stageData.samplingActive = false;
                // updateInfoText("Sampling in progress... Particles are accumulating at the end.");
                
                // Wait longer for particles to reach the end, then auto-progress to stage 1
                setTrackedTimeout(() => {
                    if (currentStage === 0) {
                        // updateInfoText("Sampling complete! Auto-progressing to advantage scaling...");
                        setTrackedTimeout(() => {
                            if (currentStage === 0) {
                                startStage1(); // Auto-progress to stage 1
                            }
                        }, 1000);
                    }
                }, 6000);
            }, 2000);
        }
        
        // Generate synthetic samples from the current data distribution
        function generateSyntheticSamples(numSamples, type) {
            const samples = [];
            const modes = getDataModes(type);
            
            for (let i = 0; i < numSamples; i++) {
                // Sample from mixture of Gaussians
                const rand = Math.random();
                let cumulativeWeight = 0;
                let selectedMode = modes[0];
                
                for (let mode of modes) {
                    cumulativeWeight += mode.weight;
                    if (rand <= cumulativeWeight) {
                        selectedMode = mode;
                        break;
                    }
                }
                
                // Sample from the selected mode
                const sample = selectedMode.mean + selectedMode.std * sampleStandardNormal();
                samples.push(Math.max(xMin + 0.1, Math.min(xMax - 0.1, sample)));
            }
            
            return samples;
        }

        // Start Stage 1: Scale by Advantage
        function startStage1() {
            currentStage = 1;
            updateButtonStates();
            
            // Check if we have enough particle samples
            const minSamples = 20;
            let samplesForClustering = stageData.particleEndPositions;
            
            if (samplesForClustering.length < minSamples) {
                console.warn(`Only ${samplesForClustering.length} particle samples collected, generating synthetic samples`);
                const syntheticSamples = generateSyntheticSamples(50, currentDataType);
                samplesForClustering = [...samplesForClustering, ...syntheticSamples];
                updateInfoText(`Generated ${syntheticSamples.length} synthetic samples due to insufficient particle data.`);
            }
            
            // Fit k centroids to the particle end positions (or synthetic samples)
            stageData.centroids = kMeansClustering(samplesForClustering, numCentroids);
            
            // Validate centroids
            if (stageData.centroids.length === 0) {
                console.warn('K-means clustering failed, using fallback centroids');
                const modes = getDataModes(currentDataType);
                stageData.centroids = modes.map(mode => ({
                    mean: mode.mean,
                    std: Math.max(0.2, mode.std),
                    count: 10,
                    weight: mode.weight
                }));
            }
            
            // Apply advantage scaling to centroids
            stageData.scaledCentroids = applyAdvantageScaling(stageData.centroids);
            
            // Validate scaled centroids
            if (stageData.scaledCentroids.length === 0) {
                console.warn('Advantage scaling failed, using fallback');
                stageData.scaledCentroids = [{
                    mean: 0,
                    std: 0.3,
                    count: 10,
                    weight: 1.0,
                    advantage: 1.0,
                    scaledWeight: 1.0
                }];
            }
            
            // Update plot to show scaled distribution
            plotFlow();
            
            // updateInfoText(`Fitted ${stageData.centroids.length} centroids and scaled by advantage! The data distribution now shows the advantage-weighted centroids.`);
            updateInfoText(`Data distribution updated to the sample distribution scaled by advantage.`);
            
            // Auto-progress to stage 2 (using tracked timeout)
            setTrackedTimeout(() => {
                if (currentStage !== 1) return; // Check if stage changed
                // updateInfoText("Auto-progressing to flow redirection...");
                setTrackedTimeout(() => {
                    if (currentStage === 1) {
                        startStage2(); // Auto-progress to stage 2
                    }
                }, 1000);
            }, 2000);
        }
        
        // Start Stage 2: Redirect the Flow
        function startStage2() {
            currentStage = 2;
            updateButtonStates();
            
            // Reset animation state
            resetAnimationState();
            
            // Normalize and set target modes
            stageData.targetModes = normalizeAdvantageCentroids(stageData.scaledCentroids);
            stageData.transitionProgress = 0;
            stageData.originalModes = null; // Reset for new transition
            
            // Clear particles for a clean transition
            particles = [];
            
            updateInfoText("Redirecting the marginal flow...");
            
            // Start the transition animation
            animateDistributionTransition();
        }
        
        // Track all active timeouts for proper cleanup
        let activeTimeouts = [];
        
        // Helper function to set trackable timeouts
        function setTrackedTimeout(callback, delay) {
            const timeoutId = setTimeout(() => {
                // Remove from active timeouts when it executes
                activeTimeouts = activeTimeouts.filter(id => id !== timeoutId);
                callback();
            }, delay);
            activeTimeouts.push(timeoutId);
            return timeoutId;
        }
        
        // Clear all active timeouts
        function clearAllTimeouts() {
            activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
            activeTimeouts = [];
        }
        
        // Reset the entire visualization
        function resetVisualization() {
            console.log('Resetting visualization');
            
            // Clear ALL pending timeouts first
            clearAllTimeouts();
            
            // Stop any ongoing animations
            stopAnimation();
            resetAnimationState();
            
            // Reset all state
            currentStage = -1;
            particles = [];
            stageData = {
                particleEndPositions: [],
                centroids: [],
                scaledCentroids: [],
                targetModes: null,
                transitionProgress: 0,
                samplingActive: false
            };
            
            // Reset data modes to original values
            customDataModes = {
                bimodal: [
                    {mean: -0.7, std: 0.3, weight: 0.6},
                    {mean: 0.7, std: 0.3, weight: 0.4}
                ],
                trimodal: [
                    {mean: -1, std: 0.3, weight: 0.33},
                    {mean: 0, std: 0.3, weight: 0.34},
                    {mean: 1, std: 0.3, weight: 0.33}
                ]
            };
            
            // Reset advantage modes to original values
            advantageModes = [
                {mean: -0.5, std: 0.4, weight: 0.45},
                {mean: 0.6, std: 0.3, weight: 0.55}
            ];
            
            // Reset data trace animation
            dataTraceAnimation = {
                isAnimating: false,
                startTime: null,
                duration: 1000,
                startDataY: null,
                targetDataY: null,
                currentDataY: null
            };
            
            // Reset animation state
            animationState = {
                transitionStartTime: null,
                maxTransitionDuration: 15000,
                lastProgressCheck: null,
                stuckCheckInterval: null
            };
            
            // Reset button states
            updateButtonStates();
            
            // Reset info text
            updateInfoText("Visualization reset. Ready to start a new cycle.");
            
            // Replot and restart
            plotFlow();
            startAnimation();
            
            // Auto-start after a brief delay (using tracked timeout)
            setTrackedTimeout(() => {
                if (currentStage === -1) { // Only start if still in reset state
                    startStage0();
                }
            }, 2000);
        }
        
        // Update button states based on current stage
        function updateButtonStates() {
            const buttons = ['sampleBtn', 'advantageBtn', 'redirectBtn'];
            buttons.forEach((btnId, index) => {
                const btn = document.getElementById(btnId);
                if (index === currentStage) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
                // Disable all buttons since we're in autoplay mode
                btn.disabled = true;
            });
            
            // Reset button is always enabled and never has active state
            const resetBtn = document.getElementById('resetBtn');
            if (resetBtn) {
                resetBtn.disabled = false;
                resetBtn.classList.remove('active');
            }
        }
        
        // Update info text
        function updateInfoText(text) {
            document.getElementById('infoText').textContent = text;
        }
        
        // Create density matrix for heatmap
        function createDensityMatrix(type) {
            const z = [];
            for (let i = 0; i < nPoints; i++) {
                const row = [];
                const x = xGrid[i];
                for (let j = 0; j < nTimeSteps; j++) {
                    const t = tGrid[j];
                    row.push(flowPDF(x, t, type));
                }
                z.push(row);
            }
            return z;
        }
        
        // Initialize canvas
        function initCanvas() {
            canvas = document.getElementById('particle-canvas');
            ctx = canvas.getContext('2d');
            updateCanvasSize();
            
            // Add mouse event listeners for dragging
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            
            // Add touch event listeners for mobile
            if (isMobile) {
                canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
                canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
                canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            }
        }
        
        // Update canvas size to match plot
        function updateCanvasSize() {
            const plotDiv = document.getElementById('plot-container');
            if (!plotDiv || !plotDiv._fullLayout) return;
            
            const rect = plotDiv.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1; // Get device pixel ratio
            
            // Set actual canvas size in memory (scaled for high-DPI)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            ctx.scale(dpr, dpr);

            canvasWidth = rect.width;
            canvasHeight = rect.height;
            
            // Update coordinate mapping
            updateCoordinateMapping();
        }
        
        // Update coordinate mapping from data space to pixel space
        function updateCoordinateMapping() {
            const plotDiv = document.getElementById('plot-container');
            if (!plotDiv || !plotDiv._fullLayout) {
                coordinateMapping = null;
                dataDistCoordinateMapping = null;
                advantageCoordinateMapping = null;
                return;
            }
            
            const layout = plotDiv._fullLayout;
            const xaxis = layout.xaxis;
            const yaxis = layout.yaxis;
            const xaxis2 = layout.xaxis2; // Data distribution x-axis
            const yaxis2 = layout.yaxis2; // Data distribution y-axis
            const xaxis3 = layout.xaxis3; // Advantage x-axis  
            const yaxis3 = layout.yaxis3; // Advantage y-axis
            
            // Main plot coordinate mapping
            coordinateMapping = {
                xMin: xaxis.range[0],
                xMax: xaxis.range[1],
                yMin: yaxis.range[0],
                yMax: yaxis.range[1],
                plotLeft: xaxis._offset,
                plotTop: yaxis._offset,
                plotWidth: xaxis._length,
                plotHeight: yaxis._length
            };
            
            // Data distribution plot coordinate mapping
            if (xaxis2 && yaxis2) {
                dataDistCoordinateMapping = {
                    xMin: xaxis2.range[0],
                    xMax: xaxis2.range[1],
                    yMin: yaxis2.range[0],
                    yMax: yaxis2.range[1],
                    plotLeft: xaxis2._offset,
                    plotTop: yaxis2._offset,
                    plotWidth: xaxis2._length,
                    plotHeight: yaxis2._length
                };
            }
            
            // Advantage plot coordinate mapping (now the rightmost)
            if (xaxis3 && yaxis3) {
                advantageCoordinateMapping = {
                    xMin: xaxis3.range[0],
                    xMax: xaxis3.range[1],
                    yMin: yaxis3.range[0],
                    yMax: yaxis3.range[1],
                    plotLeft: xaxis3._offset,
                    plotTop: yaxis3._offset,
                    plotWidth: xaxis3._length,
                    plotHeight: yaxis3._length
                };
            }
        }
        
        // Convert data coordinates to pixel coordinates
        function dataToPixel(t, x) {
            if (!coordinateMapping) return {x: 0, y: 0};
            
            // Map t (time) to x-axis pixels
            const pixelX = coordinateMapping.plotLeft + 
                          (t - coordinateMapping.xMin) / (coordinateMapping.xMax - coordinateMapping.xMin) * 
                          coordinateMapping.plotWidth;
            
            // Map x (position) to y-axis pixels
            // Note: y-axis is inverted in pixel coordinates
            const pixelY = coordinateMapping.plotTop + coordinateMapping.plotHeight -
                          ((x - coordinateMapping.yMin) / (coordinateMapping.yMax - coordinateMapping.yMin) * 
                          coordinateMapping.plotHeight);
            
            return {x: pixelX, y: pixelY};
        }
        
        // Convert advantage coordinates to pixel coordinates
        function advantageToPixel(xDist, yDist) {
            if (!advantageCoordinateMapping) return {x: 0, y: 0};
            
            const pixelX = advantageCoordinateMapping.plotLeft + 
                          (xDist - advantageCoordinateMapping.xMin) / 
                          (advantageCoordinateMapping.xMax - advantageCoordinateMapping.xMin) * 
                          advantageCoordinateMapping.plotWidth;
            
            const pixelY = advantageCoordinateMapping.plotTop + advantageCoordinateMapping.plotHeight -
                          ((yDist - advantageCoordinateMapping.yMin) / 
                          (advantageCoordinateMapping.yMax - advantageCoordinateMapping.yMin) * 
                          advantageCoordinateMapping.plotHeight);
            
            return {x: pixelX, y: pixelY};
        }
        
        // Convert pixel coordinates to data coordinates
        function pixelToData(pixelX, pixelY) {
            if (!coordinateMapping) return {t: 0, x: 0};
            
            // Map pixel x to time
            const t = (pixelX - coordinateMapping.plotLeft) / coordinateMapping.plotWidth * 
                     (coordinateMapping.xMax - coordinateMapping.xMin) + coordinateMapping.xMin;
            
            // Map pixel y to data x (inverted)
            const x = (1 - (pixelY - coordinateMapping.plotTop) / coordinateMapping.plotHeight) * 
                     (coordinateMapping.yMax - coordinateMapping.yMin) + coordinateMapping.yMin;
            
            return {t: t, x: x};
        }
        
        // Get control point position for an advantage mode
        function getControlPointPosition(mode, index) {
            // Calculate the position on the advantage curve
            const scale = 0.15; // This matches the scale factor used in plotting
            const advantageMax = Math.max(...xGridExtended.map(x => advantageFunction(x)));
            
            // The x position on the advantage plot (rightmost)
            const peakHeight = mode.weight * gaussianPDF(mode.mean, mode.mean, mode.std);
            const xPos = 0.82 + scale * peakHeight / advantageMax; // Changed from 0.9 to 0.82
            
            // Use the advantage coordinate mapping
            return advantageToPixel(xPos, mode.mean);
        }
        
        // Check if mouse is over a control point
        function getControlPointAtPosition(mouseX, mouseY) {
            for (let i = 0; i < advantageModes.length; i++) {
                const pos = getControlPointPosition(advantageModes[i], i);
                if (!pos) continue;
                const dist = Math.sqrt(Math.pow(mouseX - pos.x, 2) + Math.pow(mouseY - pos.y, 2));
                if (dist <= controlPointHoverRadius) {
                    return i;
                }
            }
            return -1;
        }
        
        // Mouse event handlers
        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const modeIndex = getControlPointAtPosition(mouseX, mouseY);
            if (modeIndex >= 0) {
                isDragging = true;
                draggedModeIndex = modeIndex;
                dragStartX = mouseX;
                dragStartY = mouseY;
                dragStartWeight = advantageModes[modeIndex].weight;
                dragStartMean = advantageModes[modeIndex].mean;
                canvas.classList.add('dragging');
                e.preventDefault();
            }
        }
        
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isDragging && draggedModeIndex >= 0) {
                // Update mean based on vertical movement
                const deltaY = mouseY - dragStartY;
                const meanChange = -deltaY * 0.005; // Scale factor for mean changes
                advantageModes[draggedModeIndex].mean = Math.max(xMin + 0.2, Math.min(xMax - 0.2, dragStartMean + meanChange));
                
                // Update weight based on horizontal movement
                const deltaX = mouseX - dragStartX;
                const weightChange = deltaX * 0.005; // Scale factor for weight changes
                
                // For weight changes, allow temporary denormalization
                let newWeight = Math.max(0.05, dragStartWeight + weightChange);
                advantageModes[draggedModeIndex].weight = newWeight;
                
                // Calculate total weight
                const totalWeight = advantageModes.reduce((sum, mode) => sum + mode.weight, 0);
                
                // Only normalize if total weight is significantly different from 1.0
                if (Math.abs(totalWeight - 1.0) > 0.01) {
                    advantageModes.forEach(mode => mode.weight /= totalWeight);
                }
                
                // Update the plot
                plotFlow();
            } else {
                // Check for hover
                const newHoveredIndex = getControlPointAtPosition(mouseX, mouseY);
                if (newHoveredIndex !== hoveredModeIndex) {
                    hoveredModeIndex = newHoveredIndex;
                    canvas.style.cursor = hoveredModeIndex >= 0 ? 'grab' : 'default';
                    renderParticles(); // Re-render to show hover effect
                }
            }
        }
        
        function handleMouseUp(e) {
            if (isDragging) {
                // Final normalization to ensure weights sum to exactly 1.0
                const totalWeight = advantageModes.reduce((sum, mode) => sum + mode.weight, 0);
                advantageModes.forEach(mode => mode.weight /= totalWeight);
                
                isDragging = false;
                draggedModeIndex = -1;
                canvas.classList.remove('dragging');
                
                // Update plot one final time with normalized weights
                plotFlow();
            }
        }
        
        // Touch event handlers for mobile
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            const modeIndex = getControlPointAtPosition(mouseX, mouseY);
            if (modeIndex >= 0) {
                isDragging = true;
                draggedModeIndex = modeIndex;
                dragStartX = mouseX;
                dragStartY = mouseY;
                dragStartWeight = advantageModes[modeIndex].weight;
                dragStartMean = advantageModes[modeIndex].mean;
                canvas.classList.add('dragging');
            }
        }
        
        function handleTouchMove(e) {
            e.preventDefault();
            if (isDragging && e.touches.length > 0) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const mouseX = touch.clientX - rect.left;
                const mouseY = touch.clientY - rect.top;
                
                updateDraggedMode(mouseX, mouseY);
            }
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            if (isDragging) {
                completeDrag();
            }
        }
        
        // Update dragged mode (shared between mouse and touch)
        function updateDraggedMode(mouseX, mouseY) {
            if (!isDragging || draggedModeIndex < 0) return;
            
            // Update mean based on vertical movement
            const deltaY = mouseY - dragStartY;
            const meanChange = -deltaY * 0.005; // Scale factor for mean changes
            advantageModes[draggedModeIndex].mean = Math.max(xMin + 0.2, Math.min(xMax - 0.2, dragStartMean + meanChange));
            
            // Update weight based on horizontal movement
            const deltaX = mouseX - dragStartX;
            const weightChange = deltaX * 0.005; // Scale factor for weight changes
            
            // For weight changes, allow temporary denormalization
            let newWeight = Math.max(0.05, dragStartWeight + weightChange);
            advantageModes[draggedModeIndex].weight = newWeight;
            
            // Calculate total weight
            const totalWeight = advantageModes.reduce((sum, mode) => sum + mode.weight, 0);
            
            // Only normalize if total weight is significantly different from 1.0
            if (Math.abs(totalWeight - 1.0) > 0.01) {
                advantageModes.forEach(mode => mode.weight /= totalWeight);
            }
            
            // Update the plot
            plotFlow();
        }
        
        // Complete drag operation (shared between mouse and touch)
        function completeDrag() {
            if (!isDragging) return;
            
            // Final normalization to ensure weights sum to exactly 1.0
            const totalWeight = advantageModes.reduce((sum, mode) => sum + mode.weight, 0);
            advantageModes.forEach(mode => mode.weight /= totalWeight);
            
            isDragging = false;
            draggedModeIndex = -1;
            canvas.classList.remove('dragging');
            
            // Update plot one final time with normalized weights
            plotFlow();
        }
        
        // Render control points
        function renderControlPoints() {
            if (!ctx || !coordinateMapping || !advantageCoordinateMapping) return;
            
            // Draw control points for advantage modes
            advantageModes.forEach((mode, index) => {
                const pos = getControlPointPosition(mode, index);
                if (!pos) return;
                
                const radius = (index === hoveredModeIndex || index === draggedModeIndex) ? 
                              controlPointHoverRadius : controlPointRadius;
                
                // Draw shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                // Draw control point
                ctx.fillStyle = '#C8372C';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Draw label - COMMENTED OUT to remove number labels
                // ctx.fillStyle = '#333';
                // ctx.font = 'bold 12px Arial';
                // ctx.textAlign = 'left';
                // ctx.fillText(`${mode.weight.toFixed(2)}`, pos.x + 15, pos.y + 4);
            });
        }
        
        // Render particles on canvas
        function renderParticles() {
            if (!ctx || !coordinateMapping) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Enable antialiasing
            ctx.imageSmoothingEnabled = true;
            
            // Draw particles
            particles.forEach(particle => {
                const pos = dataToPixel(particle.t, particle.x);
                
                // Draw trajectory if enabled (but not for accumulated particles)
                if (showParticleTraces && particle.trajectory.length > 1 && !particle.isAccumulated && !particle.fading) {
                    ctx.globalAlpha = particle.opacity * 0.4;
                    ctx.strokeStyle = particle.color;                    
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    const firstPoint = dataToPixel(particle.trajectory[0].t, particle.trajectory[0].x);
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    
                    // Draw smooth curve through trajectory points
                    for (let i = 1; i < particle.trajectory.length; i++) {
                        const point = dataToPixel(particle.trajectory[i].t, particle.trajectory[i].x);
                        ctx.lineTo(point.x, point.y);
                    }
                    
                    ctx.stroke();
                }
                
                // Draw particle
                ctx.globalAlpha = particle.opacity;
                
                // Draw outer circle (border)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw inner circle
                ctx.fillStyle = particle.radiusColor;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw control points on top
            renderControlPoints();
        }
        
        // Animation state for data trace
        let dataTraceAnimation = {
            isAnimating: false,
            startTime: null,
            duration: 1000, // 1 second animation
            startDataY: null,
            targetDataY: null,
            currentDataY: null
        };
        
        // Smooth data trace animation function
        function animateDataTrace(timestamp) {
            if (!dataTraceAnimation.isAnimating) return;
            
            if (!dataTraceAnimation.startTime) {
                dataTraceAnimation.startTime = timestamp;
            }
            
            const elapsed = timestamp - dataTraceAnimation.startTime;
            const progress = Math.min(elapsed / dataTraceAnimation.duration, 1);
            
            // Easing function for smooth animation
            const easeInOutCubic = (t) => {
                return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
            };
            
            const easedProgress = easeInOutCubic(progress);
            
            // Interpolate between start and target data
            dataTraceAnimation.currentDataY = dataTraceAnimation.startDataY.map((startVal, i) => {
                const targetVal = dataTraceAnimation.targetDataY[i];
                return startVal + (targetVal - startVal) * easedProgress;
            });
            
            // Update the plot with interpolated data
            updatePlotWithCurrentData();
            
            if (progress < 1) {
                // Continue animation
                requestAnimationFrame(animateDataTrace);
            } else {
                // Animation complete
                dataTraceAnimation.isAnimating = false;
                dataTraceAnimation.startTime = null;
                dataTraceAnimation.currentDataY = [...dataTraceAnimation.targetDataY];
            }
        }
        
        // Start data trace animation
        function startDataTraceAnimation(newDataY) {
            // Store current data as starting point
            if (dataTraceAnimation.currentDataY) {
                dataTraceAnimation.startDataY = [...dataTraceAnimation.currentDataY];
            } else {
                // First time - use the current data distribution
                dataTraceAnimation.startDataY = xGridExtended.map(x => dataPDF(x, currentDataType));
            }
            
            dataTraceAnimation.targetDataY = [...newDataY];
            dataTraceAnimation.isAnimating = true;
            dataTraceAnimation.startTime = null;
            
            // Start the animation
            requestAnimationFrame(animateDataTrace);
        }
        
        // Update plot with current animated data
        function updatePlotWithCurrentData() {
            const densityMatrix = createDensityMatrix(currentDataType);
            
            // Use animated data if available, otherwise compute current data
            let dataY;
            if (dataTraceAnimation.currentDataY) {
                dataY = dataTraceAnimation.currentDataY;
            } else if (currentStage >= 1 && stageData.scaledCentroids.length > 0) {
                // Show the advantage-scaled centroids
                dataY = xGridExtended.map(x => {
                    let pdf = 0;
                    stageData.scaledCentroids.forEach(centroid => {
                        pdf += centroid.scaledWeight * gaussianPDF(x, centroid.mean, centroid.std);
                    });
                    return pdf;
                });
            } else {
                // Show the regular data distribution
                dataY = xGridExtended.map(x => dataPDF(x, currentDataType));
            }
            
            // Create advantage trace (rightmost)
            const advantageY = xGridExtended.map(x => advantageFunction(x));
            
            // Normalize for visualization
            const dataMax = Math.max(...dataY);
            const advantageMax = Math.max(...advantageY);
            const scale = 0.15; // Scale factor for side distributions
            
            // Create heatmap trace
            const heatmapTrace = {
                x: tGrid,
                y: xGrid,
                z: densityMatrix,
                type: 'heatmap',
                colorscale: "Portland",
                showscale: false,
                hoverinfo: 'none',
            };
            
            const dataTrace = {
                x: dataY.map(y => 0.655 + scale * y / dataMax),
                y: xGridExtended,
                type: 'scatter',
                mode: 'lines+markers',
                line: {
                    width: 3,
                    dash: 'dash'
                },
                marker: {
                    color: dataY,
                    colorscale: 'Portland',
                    size: 0
                },
                fill: 'tozerox',
                fillcolor: '#18327E',
                name: 'Data',
                xaxis: 'x2',
                yaxis: 'y2',
                hoverinfo: 'none'
            };
            
            // Advantage trace - rightmost
            const advantageTrace = {
                x: advantageY.map(y => 0.82 + scale * y / advantageMax),
                y: xGridExtended,
                type: 'scatter',
                mode: 'lines+markers',
                line: {
                    width: 3,
                    dash: 'solid'
                },
                marker: {
                    color: '#C8372C',
                    size: 0
                },
                fill: 'tozerox',
                fillcolor: 'rgba(200, 55, 44, 0.1)',
                name: 'Reward',
                xaxis: 'x3',
                yaxis: 'y3',
                hoverinfo: 'none'
            };

            const data = [heatmapTrace, dataTrace, advantageTrace];
            
            const layout = {
                hovermode: false,
                xaxis: {
                    title: {
                        text: 'Timestep (t)',
                        font: {weight: 'bold'},
                        standoff: 20  // Add space between title and axis
                    },
                    domain: [0.1, 0.65],
                    range: [0, 1],
                    zeroline: false,
                },
                yaxis: {
                    range: [xMin, xMax],
                    showticklabels: false,
                    ticks: '',
                    zeroline: false,
                },
                xaxis2: {
                    domain: [0.655, 0.77],
                    showticklabels: false,
                    showgrid: false,
                    zeroline: false,
                    range: [0.655, 0.655 + 1.1 * scale]
                },
                yaxis2: {
                    anchor: 'x2',
                    showticklabels: false,
                    zeroline: false,
                    showgrid: false,
                    range: [xMinExtended, xMaxExtended]
                },
                xaxis3: {
                    domain: [0.82, 0.92],
                    showticklabels: false,
                    showgrid: false,
                    zeroline: false,
                    range: [0.82, 0.82 + scale]
                },
                yaxis3: {
                    anchor: 'x3',
                    showticklabels: false,
                    showgrid: false,
                    zeroline: false,
                    range: [xMinExtended, xMaxExtended]
                },
                annotations: [
                    {
                        text: '',
                        x: 0.71,
                        y: 1.15,
                        xref: 'paper',
                        yref: 'paper',
                        showarrow: false,
                        font: {size: 20, color: '#18327E', weight: 'bold'}
                    },
                    // {
                    //     text: 'Reward',
                    //     x: 0.87,
                    //     y: 1.15,
                    //     xref: 'paper',
                    //     yref: 'paper',
                    //     showarrow: false,
                    //     font: {size: 20, color: '#C8372C', weight: 'bold'}
                    // }
                ],
                showlegend: false,
                margin: {t: 20, l: 40, r: 40, b: 60},  // Increased bottom margin from 20 to 60
            };
            
            const config = {
                responsive: true,
                displayModeBar: false
            };
            
            // Use Plotly.react for faster updates during animation
            Plotly.react('plot-container', data, layout, config).then(() => {
                // Update coordinate mapping and render particles
                updateCanvasSize();
                renderParticles();
            });
        }
        
        // Modified plot function to trigger animations
        function plotFlow() {
            // Calculate what the new data should be
            let newDataY;
            if (currentStage >= 1 && stageData.scaledCentroids.length > 0) {
                // Show the advantage-scaled centroids
                newDataY = xGridExtended.map(x => {
                    let pdf = 0;
                    stageData.scaledCentroids.forEach(centroid => {
                        pdf += centroid.scaledWeight * gaussianPDF(x, centroid.mean, centroid.std);
                    });
                    return pdf;
                });
            } else {
                // Show the regular data distribution
                newDataY = xGridExtended.map(x => dataPDF(x, currentDataType));
            }
            
            // Check if we need to animate the data trace
            const shouldAnimate = dataTraceAnimation.currentDataY && 
                                 !dataTraceAnimation.isAnimating && 
                                 currentStage >= 1; // Only animate when scaling is applied
            
            if (shouldAnimate) {
                // Start smooth animation to new data
                startDataTraceAnimation(newDataY);
            } else {
                // Update immediately (first load or during distribution transition)
                dataTraceAnimation.currentDataY = newDataY;
                updatePlotWithCurrentData();
            }
        }
        
        // Add window resize handler
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                updateCanvasSize();
                renderParticles();
            }, 250);
        });
        
        // Animation functions
        function animate(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            
            const deltaTime = (timestamp - lastTimestamp) / 1000; // Convert to seconds
            lastTimestamp = timestamp;
            
            // Update all particles
            const dt = deltaTime * animationSpeed;

            // Only add particles if sampling is active
            if (stageData.samplingActive && Math.random() < particleRate) {
                addMoreParticles(1);
            }
            
            // Filter out dead particles while updating alive ones
            particles = particles.filter(particle => {
                return particle.update(dt, currentDataType);
            });
            
            // Render particles on canvas
            renderParticles();
            
            // Keep animation running
            if (animationId) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function startAnimation() {
            if (!animationId) {
                lastTimestamp = null;
                animationId = requestAnimationFrame(animate);
            }
        }
        
        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                lastTimestamp = null;
            }
        }
        
        function resetAnimation() {
            particles = [new Particle()];
            renderParticles();
            // Auto-restart animation if it's not running
            if (!animationId) {
                startAnimation();
            }
        }
        
        function addMoreParticles(numParticles) {
            // Default to 10 particles
            if (numParticles === undefined) {
                numParticles = 10;
            }
            for (let i = 0; i < numParticles; i++) {
                particles.push(new Particle());
            }
            renderParticles();
        }
        
        // Change data distribution
        function changeDataDistribution(type) {
            currentDataType = type;
            resetAnimation();
            plotFlow();
        }
        
        // Initialize canvas and start
        initCanvas();
        plotFlow();
        startAnimation();
        
        // Auto-start the cycle
        setTimeout(() => {
            startStage0(); // Auto-start the first stage
        }, 1000);

        // Add window event listeners for focus/blur handling
        window.addEventListener('focus', handleWindowFocus);
        window.addEventListener('blur', () => {
            // Window lost focus - the animation might get paused
        });
    </script>
</body>
</html>